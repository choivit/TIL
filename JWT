- (Json Web Token): 쿠키와 세션의 단점을 보완하고자 하는 과정 속에서 나타난 하나의 **인터넷 표준 인증 방식**. 인증에 필요한 정보들을 Token에 담아 암호화시켜 사용하는 토큰
- 기본적인 인증을 진행하는 구조는 Cookie와 크게 다르지 않음. 다만, JWT는 서명된 토큰이라는 점. 공개/개인 키를 쌍으로 이용하여 토큰에 서명을 할 경우 서명된 토큰은 개인 키를 보유한 서버가 서명된 토큰이 정상적인 토큰인지 인증할 수 있음.
- 구조
    - 각각의 구성요소가 점(.)으로 구분되어 있으며 Header, Payload, Signature가 있음.
    - 구성요소
        - Header
            - 토큰의 타입이나 서명 생성에 어떤 알고리즘이 사용되었는지 저장.
            
            ```jsx
            {
            	"typ": "JWT",
            	"alg": "HS512"
            }
            ```
            
            - 위의 예제 같은 경우 현재 토큰의 타입이 JWT고, 개인키로 HS512 알고리즘이 적용되어 암호화가 되어있다고 확인할 수 있음.
        - Payload
            - (토큰에서 사용할 정보의 조각→)Claim이라는 사용자나 토큰에 대한 property를 key-value의 형태로 저장. 어떤 Claim을 넣을지는 개인의 마음!
            - JWT의 표준스펙
                - KEY의 이름은 3글자. JWT의 핵심 목표는 사용자에 대한, 토큰에 대한 표현을 압축하는 것이어서 이를 정의한 것
                    1. iss (Issuer): 토큰 발급자
                    2. sub (Subject): 토큰 제목 - 토큰에서 사용자에 대한 식별 값이 됨.
                    3. aud (Audience): 토큰 대상자
                    4. exp (Expiration Time): 토큰 만료 시간
                    5. nbf (Not Before): 토큰 활성 날짜 (이 날짜 이전의 토큰을 활성되지 않음을 보장)
                    6. iat (Issued At): 토큰 발급 시간
                    7. jti (JWT Id): JWT 토큰 식별자 (issuer가 여러 명일 때 이를 구분하기 위한 값)
                - 총 7가지의 Claim스펙이 있으나 7가지를 모두 포함해야 하는 것은 아니고 상황에 따라 해당 서버가 가져야 할 인증 체계에 따라 사용하면 됨.
                - 표준 스펙 외에도 필요 여부에 따라 추가 가능.
                    - 예: Access Token과 Refresh Token을 구분하고 싶다면 “token_type”이라는 커스텀된 Claim을 만들고 값을 아래와 같은 “access token”으로 두어 구분 지어도 됨.
            - 가장 중요한 것은 **payload에 민감한 정보를 담지 않는 것**. header와 payload는 json이 디코딩 되어 있을 뿐 특별한 암호화가 되어 있지 않기 때문에 누구나 jwt를 가지고 디코딩을 한다면 header나 payload에 담긴 값을 알 수 있기 때문.
            - JWT를 디코딩 해보면 알지만 JWT는 header와 payload는 특별한 암호화 없이 흔히 사용할 수 있는 base64 인코딩을 사용하기 때문에 서버가 아니더라도 그 값들을 확인 할 수 있음. 그래서 JWT는 단순히 “식별을 하기 위한” 정보만을 담아두어야 하는 것.
            - 단순하게 헤더에 민감한 정보를 담고 싶을때 한번 더 암호화를 시켜 전달은 가능할 수 있으나 이 자체만으로도 많은 리소스를 사용하기 때문에 신중하게 사용해야 함. 매 http 요청마다 한 번의 복호화가 더 추가되는 셈이기 때문.
        - Signature
            - 가장 중요한 서명.
            - signature 값이 만들지는 과정
                1. signature값은 앞선 header와 payload의 디코딩된 값을 더함.
                2. 더한 값을 서버가 가진 개인키(예: your-256-bit-secret)로 암호화.
            - 이러한 과정을 통해 서버에 있는 개인키로만 암호화를 풀 수 있기 때문에 다른 클라이언트는 임의로 Signature를 복호화 할 수 없음.
- JWT의 복호화, 인증 방법
    - JWT 토큰을 클라이언트가 서버로 요청과 동시에 전달.
    - 서버가 가지고 있는 개인키로 Signature를 복호화 한 다음, 암호화된 header, payload를 디코딩하여 Signature 속에 포함된 header, payload와 비교하여 일치한다면 인증을 허용.
    - 만약 다른 클라이언트가 payload의 값이 변조된 JWT를 요청하더라도 서버가 애초에 발급했던 Signature 안의 payload와 다르기 때문에 인증이 불가능함.
- 장점
    - 쿠키와 세션의 모든 단점을 해결하는 것이 JWT라 기존의 단점들이 장점임.
    - 토큰 자체가 인증된 정보라 세션 저장소와 같은 별도의 인증 저장소가 “필수적”으로 필요하지 않음
    - 세션과 다르게 클라이언트의 상태를 서버가 저장해 두지 않아도 됨.
    - signature를 공통 키 개인키 암호화를 통해 막아두었기 때문에 데이터에 대한 보완(안?)성이 증가
    - 다른 서비스에 이용할 수 있는 공통적인 스펙으로 사용 가능
